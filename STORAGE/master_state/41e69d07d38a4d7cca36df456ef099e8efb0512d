{"total": 0.0, "marketplace_profit_details": {}, "utxos": ["ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe_0"], "utxos_data": {"ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe_0": {"output": {"amount": 0.0, "locking_script": "OP_DUP OP_HASH160 31f2ac8088005412c7b031a6e342b17a65a48d01 OP_EQUAL_VERIFY OP_CHECKSIG OP_SC 41e69d07d38a4d7cca36df456ef099e8efb0512d", "network": "nig", "transaction_hash": "ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe", "timestamp": 1717152088.259863, "output_index": 0, "fee_interface": 0, "fee_miner": 0, "fee_node": 0, "account_list": ["41e69d07d38a4d7cca36df456ef099e8efb0512d"], "smart_contract_sender": "31f2ac8088005412c7b031a6e342b17a65a48d01", "smart_contract_new": true, "smart_contract_account": "41e69d07d38a4d7cca36df456ef099e8efb0512d", "smart_contract_flag": true, "smart_contract_gas": 999771.9, "smart_contract_memory": [["MarketplaceRequestCode", "marketplace_request_code", ["code"], ["\n###VERSION:1\n\nclass MarketplaceRequest:\n    def __init__(self):\n        self.account=None\n        self.step=0\n        self.new_user_flag=False\n        self.timestamp=datetime.timestamp(datetime.utcnow())\n        self.timestamp_step1=None\n        self.timestamp_step2=None\n        self.timestamp_step3=None\n        self.timestamp_step4=None\n        self.requested_amount=0\n        self.requested_currency='EUR'\n        self.requested_deposit=0\n        self.requested_nig=0\n        self.requested_nig_step2=None\n        self.requested_nig_step2_flag=False\n        self.timestamp_nig=None\n        self.buyer_public_key_hex=None\n        self.buyer_public_key_hash=None\n        self.buyer_public_key_hash=None\n        self.buyer_reput_trans=0\n        self.buyer_reput_reliability=0\n        self.seller_public_key_hex=\"\"\n        self.seller_public_key_hash=\"\"\n        self.encrypted_account=\"\"\n        self.mp_request_signature=None\n        self.mp_request_id=random.randint(10000000, 99999999)\n        self.previous_mp_request_name=None\n        self.mp_request_name=None\n        self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n        self.smart_contract_ref=None\n        self.reputation_buyer=0\n        self.reputation_seller=0\n\n    def get_mp_details(self,step):\n        mp_details = [self.timestamp,self.buyer_public_key_hash,self.buyer_public_key_hex,self.requested_amount,self.mp_request_id]\n        if self.requested_nig_step2_flag is True:requested_nig=self.requested_nig_step2\n        else:requested_nig=self.requested_nig\n        if self.step>=1:\n            self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n            mp_details.extend([requested_nig,self.seller_safety_coef])\n        if self.step>=2:mp_details.extend([self.seller_public_key_hex,self.seller_public_key_hash,self.requested_deposit])\n        if self.step==99:mp_details.append(\"cancellation\")\n        if self.step==66:mp_details.append(\"payment default\")\n        return mp_details\n\n    def get_requested_deposit(self):\n        return self.requested_deposit\n\n    def get_new_user_flag(self):\n        return self.new_user_flag\n\n    def get_reputation(self):\n        if self.reputation_buyer!=0 or self.reputation_seller!=0:return {self.buyer_public_key_hash:self.reputation_buyer,self.seller_public_key_hash:self.reputation_seller}\n        else:return None\n\n    def get_mp_info(self,step,user_public_key_hash):\n        try:step=int(step)\n        except:step=99\n        mp_details=None\n        flag=False\n        readonly_flag=False\n        if self.step!=4 and self.step!=45 and self.step!=66 and self.step!=98 and self.step!=99:\n            if step==1:\n                flag=True\n                if self.buyer_public_key_hash==user_public_key_hash:readonly_flag=True\n            if step==2:\n                if self.buyer_public_key_hash==user_public_key_hash:flag=True\n                if self.step==1:readonly_flag=True\n                if self.step==3:readonly_flag=True\n            if step==3:\n                if self.seller_public_key_hash==user_public_key_hash:flag=True\n                if self.step==2:readonly_flag=True\n            if flag is True:\n                mp_details = {\"timestamp_nig\": self.timestamp,\"requester_public_key_hash\": self.buyer_public_key_hash,\"requester_public_key_hex\": self.buyer_public_key_hex,\"seller_public_key_hash\": self.seller_public_key_hash,\"requested_amount\": self.requested_amount,\"requested_currency\":self.requested_currency,\"requested_nig\": self.requested_nig,\"payment_ref\": self.mp_request_name}\n                mp_details['seller_public_key_hex']=self.seller_public_key_hex\n                mp_details['encrypted_account']=self.encrypted_account\n                mp_details['smart_contract_ref']=self.smart_contract_ref\n                mp_details['readonly_flag']=readonly_flag\n                mp_details['buyer_reput_trans']=self.buyer_reput_trans\n                mp_details['buyer_reput_reliability']=self.buyer_reput_reliability\n                mp_details['step']=self.step\n        return mp_details\n\n    def get_mp_info_archive(self,step):\n        mp_details=None\n        if step==self.step:\n            mp_details = {\"timestamp_nig\": self.timestamp_step4, \"readonly_flag\":False}\n        return mp_details\n\n    def step1(self,mp_request_name,buyer_public_key_hash,buyer_public_key_hex,requested_amount,smart_contract_ref,new_user_flag,buyer_reput_trans,buyer_reput_reliability):\n        if buyer_public_key_hash is not None and 'None' not in buyer_public_key_hash:\n            if self.step==0:\n                self.mp_request_name=mp_request_name\n                self.buyer_public_key_hash=buyer_public_key_hash\n                self.buyer_public_key_hex=buyer_public_key_hex\n                self.requested_amount=requested_amount\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)\n                self.step=1\n                self.smart_contract_ref=smart_contract_ref\n                self.timestamp_step1=datetime.timestamp(datetime.utcnow())\n                if new_user_flag==\"true\" or new_user_flag==\"True\":new_user_flag=True\n                if new_user_flag==\"false\" or new_user_flag==\"False\":\n                    new_user_flag=False\n                    self.requested_deposit=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)*GET_BUYER_SAFETY_COEF()\n                self.new_user_flag=new_user_flag\n                self.buyer_reput_trans=buyer_reput_trans\n                self.buyer_reput_reliability=buyer_reput_reliability\n            else:raise ValueError('request cannot be confirmed in step 1')\n        else:raise ValueError('Please select a buyer')\n\n    def step2(self,seller_public_key_hash,seller_public_key_hex,encrypted_account,mp_request_signature):\n        if seller_public_key_hash is not None and 'None' not in seller_public_key_hash:\n            if self.step==1:\n                self.seller_public_key_hash=seller_public_key_hash\n                self.seller_public_key_hex=seller_public_key_hex\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig_step2=copy.deepcopy(self.requested_nig)\n                self.requested_nig_step2_flag=True\n                self.requested_nig=CONVERT_2_NIG(self.requested_amount,self.timestamp_nig,self.requested_currency)\n                self.encrypted_account=encrypted_account\n                self.mp_request_signature=mp_request_signature\n                self.step=2\n                self.timestamp_step2=datetime.timestamp(datetime.utcnow())\n            else:raise ValueError('request cannot be confirmed in step 2')\n        else:raise ValueError('Please select a seller')\n            \n\n    def step3(self,mp_request_signature):\n        if self.step==2:\n            self.mp_request_signature=mp_request_signature\n            self.step=3\n            self.timestamp_step3=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in step 3')\n\n    def step4(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=4\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 4')\n\n    def step45(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=45\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=-1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 45')\n\n    def check_cancellation(self,mp_request_signature):\n        if self.step<3:\n          self.mp_request_signature=mp_request_signature\n          self.step=99\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in cancellation')\n\n    def check_payment_default(self,mp_request_signature):\n        if self.step==3:\n          self.mp_request_signature=mp_request_signature\n          self.step=66\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n          self.reputation_buyer=-1\n          self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in payment default')\n\n    def validate_step(self):\n        signature_decoded = binascii.unhexlify(self.mp_request_signature.encode(\"utf-8\"))\n        if self.step==2 or self.step==4 or self.step==45 or self.step==66:\n            public_key_bytes = self.seller_public_key_hex.encode(\"utf-8\")\n        elif self.step==3 or self.step==99:\n            public_key_bytes = self.buyer_public_key_hex.encode(\"utf-8\")\n        else:\n            raise ValueError(f'request not in predefined step:{self.step}')\n      \n        public_key_object = RSA.import_key(binascii.unhexlify(public_key_bytes))\n        transaction_bytes = json.dumps(self.get_mp_details(self.step), indent=2).encode('utf-8')\n        transaction_hash = SHA256.new(transaction_bytes)\n        pkcs1_15.new(public_key_object).verify(transaction_hash, signature_decoded)\n\n    def check_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,False)\n\n    def validate_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,True)\n\n    def check_expiration_raw(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,error_flag):\n        expiration_flag=False\n        check_now=datetime.timestamp(datetime.utcnow())\n        if self.step==1 and check_now-self.timestamp_step1>MARKETPLACE_STEP1_EXPIRATION:expiration_flag=True\n        if self.step==2 and check_now-self.timestamp_step2>MARKETPLACE_STEP2_EXPIRATION:\n            self.reputation_buyer=-1\n            expiration_flag=True\n        if self.step==3 and check_now-self.timestamp_step3>MARKETPLACE_STEP3_EXPIRATION:\n            self.reputation_seller=-1\n            expiration_flag=True\n        if expiration_flag is True:\n            self.step=98\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:\n            if error_flag is True:ValueError('smart_contract is not expired')\n        return expiration_flag\n\t\t\n    def get_mp_info_and_expiration(self,step,user_public_key_hash,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        mp_info=self.get_mp_info(step,user_public_key_hash)\n        expiration=self.check_expiration(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION)\n        return mp_info,expiration,self.requested_amount,self.step\n\n    def cancel(self,user_public_key_hash,mp_request_signature):\n        if self.step<3 and self.buyer_public_key_hash==user_public_key_hash:\n            CANCEL_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'Cancellation not possible in step:{self.step} for user:{user_public_key_hash}')\n\n    def payment_default(self,user_public_key_hash,mp_request_signature):\n        if self.step==3 and self.seller_public_key_hash==user_public_key_hash:\n            PAYMENT_DEFAULT_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'payment default not possible in step:{self.step} for user:{user_public_key_hash}')\n\n"]]], "smart_contract_memory_size": 228, "smart_contract_type": "source", "smart_contract_payload": "\n###VERSION:1\n###END\nclass MarketplaceRequestCode:\n    def __init__(self):\n        self.code='''\n###VERSION:1\n###END\nclass MarketplaceRequest:\n    def __init__(self):\n        self.account=None\n        self.step=0\n        self.new_user_flag=False\n        self.timestamp=datetime.timestamp(datetime.utcnow())\n        self.timestamp_step1=None\n        self.timestamp_step2=None\n        self.timestamp_step3=None\n        self.timestamp_step4=None\n        self.requested_amount=0\n        self.requested_currency='EUR'\n        self.requested_deposit=0\n        self.requested_nig=0\n        self.requested_nig_step2=None\n        self.requested_nig_step2_flag=False\n        self.timestamp_nig=None\n        self.buyer_public_key_hex=None\n        self.buyer_public_key_hash=None\n        self.buyer_public_key_hash=None\n        self.buyer_reput_trans=0\n        self.buyer_reput_reliability=0\n        self.seller_public_key_hex=\"\"\n        self.seller_public_key_hash=\"\"\n        self.encrypted_account=\"\"\n        self.mp_request_signature=None\n        self.mp_request_id=random.randint(10000000, 99999999)\n        self.previous_mp_request_name=None\n        self.mp_request_name=None\n        self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n        self.smart_contract_ref=None\n        self.reputation_buyer=0\n        self.reputation_seller=0\n\n    def get_mp_details(self,step):\n        mp_details = [self.timestamp,self.buyer_public_key_hash,self.buyer_public_key_hex,self.requested_amount,self.mp_request_id]\n        if self.requested_nig_step2_flag is True:requested_nig=self.requested_nig_step2\n        else:requested_nig=self.requested_nig\n        if self.step>=1:\n            self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n            mp_details.extend([requested_nig,self.seller_safety_coef])\n        if self.step>=2:mp_details.extend([self.seller_public_key_hex,self.seller_public_key_hash,self.requested_deposit])\n        if self.step==99:mp_details.append(\"cancellation\")\n        if self.step==66:mp_details.append(\"payment default\")\n        return mp_details\n\n    def get_requested_deposit(self):\n        return self.requested_deposit\n\n    def get_new_user_flag(self):\n        return self.new_user_flag\n\n    def get_reputation(self):\n        if self.reputation_buyer!=0 or self.reputation_seller!=0:return {self.buyer_public_key_hash:self.reputation_buyer,self.seller_public_key_hash:self.reputation_seller}\n        else:return None\n\n    def get_mp_info(self,step,user_public_key_hash):\n        try:step=int(step)\n        except:step=99\n        mp_details=None\n        flag=False\n        readonly_flag=False\n        if self.step!=4 and self.step!=45 and self.step!=66 and self.step!=98 and self.step!=99:\n            if step==1:\n                flag=True\n                if self.buyer_public_key_hash==user_public_key_hash:readonly_flag=True\n            if step==2:\n                if self.buyer_public_key_hash==user_public_key_hash:flag=True\n                if self.step==1:readonly_flag=True\n                if self.step==3:readonly_flag=True\n            if step==3:\n                if self.seller_public_key_hash==user_public_key_hash:flag=True\n                if self.step==2:readonly_flag=True\n            if flag is True:\n                mp_details = {\"timestamp_nig\": self.timestamp,\"requester_public_key_hash\": self.buyer_public_key_hash,\"requester_public_key_hex\": self.buyer_public_key_hex,\"seller_public_key_hash\": self.seller_public_key_hash,\"requested_amount\": self.requested_amount,\"requested_currency\":self.requested_currency,\"requested_nig\": self.requested_nig,\"payment_ref\": self.mp_request_name}\n                mp_details['seller_public_key_hex']=self.seller_public_key_hex\n                mp_details['encrypted_account']=self.encrypted_account\n                mp_details['smart_contract_ref']=self.smart_contract_ref\n                mp_details['readonly_flag']=readonly_flag\n                mp_details['buyer_reput_trans']=self.buyer_reput_trans\n                mp_details['buyer_reput_reliability']=self.buyer_reput_reliability\n                mp_details['step']=self.step\n        return mp_details\n\n    def get_mp_info_archive(self,step):\n        mp_details=None\n        if step==self.step:\n            mp_details = {\"timestamp_nig\": self.timestamp_step4, \"readonly_flag\":False}\n        return mp_details\n\n    def step1(self,mp_request_name,buyer_public_key_hash,buyer_public_key_hex,requested_amount,smart_contract_ref,new_user_flag,buyer_reput_trans,buyer_reput_reliability):\n        if buyer_public_key_hash is not None and 'None' not in buyer_public_key_hash:\n            if self.step==0:\n                self.mp_request_name=mp_request_name\n                self.buyer_public_key_hash=buyer_public_key_hash\n                self.buyer_public_key_hex=buyer_public_key_hex\n                self.requested_amount=requested_amount\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)\n                self.step=1\n                self.smart_contract_ref=smart_contract_ref\n                self.timestamp_step1=datetime.timestamp(datetime.utcnow())\n                if new_user_flag==\"true\" or new_user_flag==\"True\":new_user_flag=True\n                if new_user_flag==\"false\" or new_user_flag==\"False\":\n                    new_user_flag=False\n                    self.requested_deposit=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)*GET_BUYER_SAFETY_COEF()\n                self.new_user_flag=new_user_flag\n                self.buyer_reput_trans=buyer_reput_trans\n                self.buyer_reput_reliability=buyer_reput_reliability\n            else:raise ValueError('request cannot be confirmed in step 1')\n        else:raise ValueError('Please select a buyer')\n\n    def step2(self,seller_public_key_hash,seller_public_key_hex,encrypted_account,mp_request_signature):\n        if seller_public_key_hash is not None and 'None' not in seller_public_key_hash:\n            if self.step==1:\n                self.seller_public_key_hash=seller_public_key_hash\n                self.seller_public_key_hex=seller_public_key_hex\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig_step2=copy.deepcopy(self.requested_nig)\n                self.requested_nig_step2_flag=True\n                self.requested_nig=CONVERT_2_NIG(self.requested_amount,self.timestamp_nig,self.requested_currency)\n                self.encrypted_account=encrypted_account\n                self.mp_request_signature=mp_request_signature\n                self.step=2\n                self.timestamp_step2=datetime.timestamp(datetime.utcnow())\n            else:raise ValueError('request cannot be confirmed in step 2')\n        else:raise ValueError('Please select a seller')\n            \n\n    def step3(self,mp_request_signature):\n        if self.step==2:\n            self.mp_request_signature=mp_request_signature\n            self.step=3\n            self.timestamp_step3=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in step 3')\n\n    def step4(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=4\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 4')\n\n    def step45(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=45\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=-1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 45')\n\n    def check_cancellation(self,mp_request_signature):\n        if self.step<3:\n          self.mp_request_signature=mp_request_signature\n          self.step=99\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in cancellation')\n\n    def check_payment_default(self,mp_request_signature):\n        if self.step==3:\n          self.mp_request_signature=mp_request_signature\n          self.step=66\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n          self.reputation_buyer=-1\n          self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in payment default')\n\n    def validate_step(self):\n        signature_decoded = binascii.unhexlify(self.mp_request_signature.encode(\"utf-8\"))\n        if self.step==2 or self.step==4 or self.step==45 or self.step==66:\n            public_key_bytes = self.seller_public_key_hex.encode(\"utf-8\")\n        elif self.step==3 or self.step==99:\n            public_key_bytes = self.buyer_public_key_hex.encode(\"utf-8\")\n        else:\n            raise ValueError(f'request not in predefined step:{self.step}')\n      \n        public_key_object = RSA.import_key(binascii.unhexlify(public_key_bytes))\n        transaction_bytes = json.dumps(self.get_mp_details(self.step), indent=2).encode('utf-8')\n        transaction_hash = SHA256.new(transaction_bytes)\n        pkcs1_15.new(public_key_object).verify(transaction_hash, signature_decoded)\n\n    def check_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,False)\n\n    def validate_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,True)\n\n    def check_expiration_raw(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,error_flag):\n        expiration_flag=False\n        check_now=datetime.timestamp(datetime.utcnow())\n        if self.step==1 and check_now-self.timestamp_step1>MARKETPLACE_STEP1_EXPIRATION:expiration_flag=True\n        if self.step==2 and check_now-self.timestamp_step2>MARKETPLACE_STEP2_EXPIRATION:\n            self.reputation_buyer=-1\n            expiration_flag=True\n        if self.step==3 and check_now-self.timestamp_step3>MARKETPLACE_STEP3_EXPIRATION:\n            self.reputation_seller=-1\n            expiration_flag=True\n        if expiration_flag is True:\n            self.step=98\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:\n            if error_flag is True:ValueError('smart_contract is not expired')\n        return expiration_flag\n\t\t\n    def get_mp_info_and_expiration(self,step,user_public_key_hash,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        mp_info=self.get_mp_info(step,user_public_key_hash)\n        expiration=self.check_expiration(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION)\n        return mp_info,expiration,self.requested_amount,self.step\n\n    def cancel(self,user_public_key_hash,mp_request_signature):\n        if self.step<3 and self.buyer_public_key_hash==user_public_key_hash:\n            CANCEL_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'Cancellation not possible in step:{self.step} for user:{user_public_key_hash}')\n\n    def payment_default(self,user_public_key_hash,mp_request_signature):\n        if self.step==3 and self.seller_public_key_hash==user_public_key_hash:\n            PAYMENT_DEFAULT_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'payment default not possible in step:{self.step} for user:{user_public_key_hash}')\n\n'''\nmarketplace_request_code=MarketplaceRequestCode()\nmemory_list.add([marketplace_request_code,'marketplace_request_code',['code']])\n123456\n", "smart_contract_result": 123456, "smart_contract_transaction_hash": "ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe_0", "smart_contract_previous_transaction": null, "account_credit_list": ["abcd1234_0"], "inputs": [{"transaction_hash": "abcd1234", "output_index": 0, "unlocking_script": "040873960f23aeeeea51069ee02b8792f8a2b3b76467b34138109aa55b3e9bb0d5db97583637aa230b4630b4c0ee5afd071d7fad21e4d067d8e937f83eedb978383509b6d88d125aade061e42ff3a99f52ac01b8aa2e43dbb4534cf6d470bd0772f907b149d1686a0fa4be8422b11cf51b0f60a0ee25eb02de291e169900fe89bcb0bebf4cb78f97d724f76a5d624e34fb00e68a08a29909cf3db0adede69c863cd35d0e58478cb55ef3817afb3f8d417cc1324ae2d9a56270aadb454877231b8abe8090f7da428d78b845c69dc25538697a234d60992cc2dc350831e0d2b3a4bc3b61312ba4e07fc2cb4db2385b38bd37bc2f848ee03d58358b4567a31b29c2 30820122300d06092a864886f70d01010105000382010f003082010a0282010100e3d338c7a46785514c37293971ed3a5757fc5e9e3042bc9cba75504bde5eee57c9cc788506042425662a45d320ca23e5aaeb989e1719f064e6fe228d9f0a316a06acd708a5536bb5cc1e0b8307ee9848e00729d5a171f00e2a435e719be1da99d7039d8c331bf869270a537b104b228a91061ada0be7918e8d88c8adadb0be2823026b751db63d0b101d7146f5b50a463161877aa3130e69be35d5f4eb71073a40bd1766c4440709eae3c9f0bfbeed6fa28358334721d497b9f3d6c31b9a258fe1d89fe3ebf5bffafc36e9fc8cbd82a57b9bec0e4cea390df37a87d60d585e808559abd83d81a2f2737e235ce2fc0cdee68770d917bf093d0ad5645610b4f4230203010001", "unlocking_public_key_hash": "abcd1234_0", "network": "nig"}]}, "input": [{"unlocking_public_key_hash": "abcd1234_0", "network": "nig", "transaction_hash": "abcd1234", "output_index": 0}]}}, "marketplace": [], "marketplace_archive": [], "reputation": [], "smart_contract": [], "balance": {"credit": {"ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe_0": {"amount": 0.0, "locking_script": "OP_DUP OP_HASH160 31f2ac8088005412c7b031a6e342b17a65a48d01 OP_EQUAL_VERIFY OP_CHECKSIG OP_SC 41e69d07d38a4d7cca36df456ef099e8efb0512d", "network": "nig", "transaction_hash": "ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe", "timestamp": 1717152088.259863, "output_index": 0, "fee_interface": 0, "fee_miner": 0, "fee_node": 0, "account_list": ["41e69d07d38a4d7cca36df456ef099e8efb0512d"], "smart_contract_sender": "31f2ac8088005412c7b031a6e342b17a65a48d01", "smart_contract_new": true, "smart_contract_account": "41e69d07d38a4d7cca36df456ef099e8efb0512d", "smart_contract_flag": true, "smart_contract_gas": 999771.9, "smart_contract_memory": [["MarketplaceRequestCode", "marketplace_request_code", ["code"], ["\n###VERSION:1\n\nclass MarketplaceRequest:\n    def __init__(self):\n        self.account=None\n        self.step=0\n        self.new_user_flag=False\n        self.timestamp=datetime.timestamp(datetime.utcnow())\n        self.timestamp_step1=None\n        self.timestamp_step2=None\n        self.timestamp_step3=None\n        self.timestamp_step4=None\n        self.requested_amount=0\n        self.requested_currency='EUR'\n        self.requested_deposit=0\n        self.requested_nig=0\n        self.requested_nig_step2=None\n        self.requested_nig_step2_flag=False\n        self.timestamp_nig=None\n        self.buyer_public_key_hex=None\n        self.buyer_public_key_hash=None\n        self.buyer_public_key_hash=None\n        self.buyer_reput_trans=0\n        self.buyer_reput_reliability=0\n        self.seller_public_key_hex=\"\"\n        self.seller_public_key_hash=\"\"\n        self.encrypted_account=\"\"\n        self.mp_request_signature=None\n        self.mp_request_id=random.randint(10000000, 99999999)\n        self.previous_mp_request_name=None\n        self.mp_request_name=None\n        self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n        self.smart_contract_ref=None\n        self.reputation_buyer=0\n        self.reputation_seller=0\n\n    def get_mp_details(self,step):\n        mp_details = [self.timestamp,self.buyer_public_key_hash,self.buyer_public_key_hex,self.requested_amount,self.mp_request_id]\n        if self.requested_nig_step2_flag is True:requested_nig=self.requested_nig_step2\n        else:requested_nig=self.requested_nig\n        if self.step>=1:\n            self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n            mp_details.extend([requested_nig,self.seller_safety_coef])\n        if self.step>=2:mp_details.extend([self.seller_public_key_hex,self.seller_public_key_hash,self.requested_deposit])\n        if self.step==99:mp_details.append(\"cancellation\")\n        if self.step==66:mp_details.append(\"payment default\")\n        return mp_details\n\n    def get_requested_deposit(self):\n        return self.requested_deposit\n\n    def get_new_user_flag(self):\n        return self.new_user_flag\n\n    def get_reputation(self):\n        if self.reputation_buyer!=0 or self.reputation_seller!=0:return {self.buyer_public_key_hash:self.reputation_buyer,self.seller_public_key_hash:self.reputation_seller}\n        else:return None\n\n    def get_mp_info(self,step,user_public_key_hash):\n        try:step=int(step)\n        except:step=99\n        mp_details=None\n        flag=False\n        readonly_flag=False\n        if self.step!=4 and self.step!=45 and self.step!=66 and self.step!=98 and self.step!=99:\n            if step==1:\n                flag=True\n                if self.buyer_public_key_hash==user_public_key_hash:readonly_flag=True\n            if step==2:\n                if self.buyer_public_key_hash==user_public_key_hash:flag=True\n                if self.step==1:readonly_flag=True\n                if self.step==3:readonly_flag=True\n            if step==3:\n                if self.seller_public_key_hash==user_public_key_hash:flag=True\n                if self.step==2:readonly_flag=True\n            if flag is True:\n                mp_details = {\"timestamp_nig\": self.timestamp,\"requester_public_key_hash\": self.buyer_public_key_hash,\"requester_public_key_hex\": self.buyer_public_key_hex,\"seller_public_key_hash\": self.seller_public_key_hash,\"requested_amount\": self.requested_amount,\"requested_currency\":self.requested_currency,\"requested_nig\": self.requested_nig,\"payment_ref\": self.mp_request_name}\n                mp_details['seller_public_key_hex']=self.seller_public_key_hex\n                mp_details['encrypted_account']=self.encrypted_account\n                mp_details['smart_contract_ref']=self.smart_contract_ref\n                mp_details['readonly_flag']=readonly_flag\n                mp_details['buyer_reput_trans']=self.buyer_reput_trans\n                mp_details['buyer_reput_reliability']=self.buyer_reput_reliability\n                mp_details['step']=self.step\n        return mp_details\n\n    def get_mp_info_archive(self,step):\n        mp_details=None\n        if step==self.step:\n            mp_details = {\"timestamp_nig\": self.timestamp_step4, \"readonly_flag\":False}\n        return mp_details\n\n    def step1(self,mp_request_name,buyer_public_key_hash,buyer_public_key_hex,requested_amount,smart_contract_ref,new_user_flag,buyer_reput_trans,buyer_reput_reliability):\n        if buyer_public_key_hash is not None and 'None' not in buyer_public_key_hash:\n            if self.step==0:\n                self.mp_request_name=mp_request_name\n                self.buyer_public_key_hash=buyer_public_key_hash\n                self.buyer_public_key_hex=buyer_public_key_hex\n                self.requested_amount=requested_amount\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)\n                self.step=1\n                self.smart_contract_ref=smart_contract_ref\n                self.timestamp_step1=datetime.timestamp(datetime.utcnow())\n                if new_user_flag==\"true\" or new_user_flag==\"True\":new_user_flag=True\n                if new_user_flag==\"false\" or new_user_flag==\"False\":\n                    new_user_flag=False\n                    self.requested_deposit=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)*GET_BUYER_SAFETY_COEF()\n                self.new_user_flag=new_user_flag\n                self.buyer_reput_trans=buyer_reput_trans\n                self.buyer_reput_reliability=buyer_reput_reliability\n            else:raise ValueError('request cannot be confirmed in step 1')\n        else:raise ValueError('Please select a buyer')\n\n    def step2(self,seller_public_key_hash,seller_public_key_hex,encrypted_account,mp_request_signature):\n        if seller_public_key_hash is not None and 'None' not in seller_public_key_hash:\n            if self.step==1:\n                self.seller_public_key_hash=seller_public_key_hash\n                self.seller_public_key_hex=seller_public_key_hex\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig_step2=copy.deepcopy(self.requested_nig)\n                self.requested_nig_step2_flag=True\n                self.requested_nig=CONVERT_2_NIG(self.requested_amount,self.timestamp_nig,self.requested_currency)\n                self.encrypted_account=encrypted_account\n                self.mp_request_signature=mp_request_signature\n                self.step=2\n                self.timestamp_step2=datetime.timestamp(datetime.utcnow())\n            else:raise ValueError('request cannot be confirmed in step 2')\n        else:raise ValueError('Please select a seller')\n            \n\n    def step3(self,mp_request_signature):\n        if self.step==2:\n            self.mp_request_signature=mp_request_signature\n            self.step=3\n            self.timestamp_step3=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in step 3')\n\n    def step4(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=4\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 4')\n\n    def step45(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=45\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=-1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 45')\n\n    def check_cancellation(self,mp_request_signature):\n        if self.step<3:\n          self.mp_request_signature=mp_request_signature\n          self.step=99\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in cancellation')\n\n    def check_payment_default(self,mp_request_signature):\n        if self.step==3:\n          self.mp_request_signature=mp_request_signature\n          self.step=66\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n          self.reputation_buyer=-1\n          self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in payment default')\n\n    def validate_step(self):\n        signature_decoded = binascii.unhexlify(self.mp_request_signature.encode(\"utf-8\"))\n        if self.step==2 or self.step==4 or self.step==45 or self.step==66:\n            public_key_bytes = self.seller_public_key_hex.encode(\"utf-8\")\n        elif self.step==3 or self.step==99:\n            public_key_bytes = self.buyer_public_key_hex.encode(\"utf-8\")\n        else:\n            raise ValueError(f'request not in predefined step:{self.step}')\n      \n        public_key_object = RSA.import_key(binascii.unhexlify(public_key_bytes))\n        transaction_bytes = json.dumps(self.get_mp_details(self.step), indent=2).encode('utf-8')\n        transaction_hash = SHA256.new(transaction_bytes)\n        pkcs1_15.new(public_key_object).verify(transaction_hash, signature_decoded)\n\n    def check_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,False)\n\n    def validate_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,True)\n\n    def check_expiration_raw(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,error_flag):\n        expiration_flag=False\n        check_now=datetime.timestamp(datetime.utcnow())\n        if self.step==1 and check_now-self.timestamp_step1>MARKETPLACE_STEP1_EXPIRATION:expiration_flag=True\n        if self.step==2 and check_now-self.timestamp_step2>MARKETPLACE_STEP2_EXPIRATION:\n            self.reputation_buyer=-1\n            expiration_flag=True\n        if self.step==3 and check_now-self.timestamp_step3>MARKETPLACE_STEP3_EXPIRATION:\n            self.reputation_seller=-1\n            expiration_flag=True\n        if expiration_flag is True:\n            self.step=98\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:\n            if error_flag is True:ValueError('smart_contract is not expired')\n        return expiration_flag\n\t\t\n    def get_mp_info_and_expiration(self,step,user_public_key_hash,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        mp_info=self.get_mp_info(step,user_public_key_hash)\n        expiration=self.check_expiration(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION)\n        return mp_info,expiration,self.requested_amount,self.step\n\n    def cancel(self,user_public_key_hash,mp_request_signature):\n        if self.step<3 and self.buyer_public_key_hash==user_public_key_hash:\n            CANCEL_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'Cancellation not possible in step:{self.step} for user:{user_public_key_hash}')\n\n    def payment_default(self,user_public_key_hash,mp_request_signature):\n        if self.step==3 and self.seller_public_key_hash==user_public_key_hash:\n            PAYMENT_DEFAULT_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'payment default not possible in step:{self.step} for user:{user_public_key_hash}')\n\n"]]], "smart_contract_memory_size": 228, "smart_contract_type": "source", "smart_contract_payload": "\n###VERSION:1\n###END\nclass MarketplaceRequestCode:\n    def __init__(self):\n        self.code='''\n###VERSION:1\n###END\nclass MarketplaceRequest:\n    def __init__(self):\n        self.account=None\n        self.step=0\n        self.new_user_flag=False\n        self.timestamp=datetime.timestamp(datetime.utcnow())\n        self.timestamp_step1=None\n        self.timestamp_step2=None\n        self.timestamp_step3=None\n        self.timestamp_step4=None\n        self.requested_amount=0\n        self.requested_currency='EUR'\n        self.requested_deposit=0\n        self.requested_nig=0\n        self.requested_nig_step2=None\n        self.requested_nig_step2_flag=False\n        self.timestamp_nig=None\n        self.buyer_public_key_hex=None\n        self.buyer_public_key_hash=None\n        self.buyer_public_key_hash=None\n        self.buyer_reput_trans=0\n        self.buyer_reput_reliability=0\n        self.seller_public_key_hex=\"\"\n        self.seller_public_key_hash=\"\"\n        self.encrypted_account=\"\"\n        self.mp_request_signature=None\n        self.mp_request_id=random.randint(10000000, 99999999)\n        self.previous_mp_request_name=None\n        self.mp_request_name=None\n        self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n        self.smart_contract_ref=None\n        self.reputation_buyer=0\n        self.reputation_seller=0\n\n    def get_mp_details(self,step):\n        mp_details = [self.timestamp,self.buyer_public_key_hash,self.buyer_public_key_hex,self.requested_amount,self.mp_request_id]\n        if self.requested_nig_step2_flag is True:requested_nig=self.requested_nig_step2\n        else:requested_nig=self.requested_nig\n        if self.step>=1:\n            self.seller_safety_coef=GET_SELLER_SAFETY_COEF()\n            mp_details.extend([requested_nig,self.seller_safety_coef])\n        if self.step>=2:mp_details.extend([self.seller_public_key_hex,self.seller_public_key_hash,self.requested_deposit])\n        if self.step==99:mp_details.append(\"cancellation\")\n        if self.step==66:mp_details.append(\"payment default\")\n        return mp_details\n\n    def get_requested_deposit(self):\n        return self.requested_deposit\n\n    def get_new_user_flag(self):\n        return self.new_user_flag\n\n    def get_reputation(self):\n        if self.reputation_buyer!=0 or self.reputation_seller!=0:return {self.buyer_public_key_hash:self.reputation_buyer,self.seller_public_key_hash:self.reputation_seller}\n        else:return None\n\n    def get_mp_info(self,step,user_public_key_hash):\n        try:step=int(step)\n        except:step=99\n        mp_details=None\n        flag=False\n        readonly_flag=False\n        if self.step!=4 and self.step!=45 and self.step!=66 and self.step!=98 and self.step!=99:\n            if step==1:\n                flag=True\n                if self.buyer_public_key_hash==user_public_key_hash:readonly_flag=True\n            if step==2:\n                if self.buyer_public_key_hash==user_public_key_hash:flag=True\n                if self.step==1:readonly_flag=True\n                if self.step==3:readonly_flag=True\n            if step==3:\n                if self.seller_public_key_hash==user_public_key_hash:flag=True\n                if self.step==2:readonly_flag=True\n            if flag is True:\n                mp_details = {\"timestamp_nig\": self.timestamp,\"requester_public_key_hash\": self.buyer_public_key_hash,\"requester_public_key_hex\": self.buyer_public_key_hex,\"seller_public_key_hash\": self.seller_public_key_hash,\"requested_amount\": self.requested_amount,\"requested_currency\":self.requested_currency,\"requested_nig\": self.requested_nig,\"payment_ref\": self.mp_request_name}\n                mp_details['seller_public_key_hex']=self.seller_public_key_hex\n                mp_details['encrypted_account']=self.encrypted_account\n                mp_details['smart_contract_ref']=self.smart_contract_ref\n                mp_details['readonly_flag']=readonly_flag\n                mp_details['buyer_reput_trans']=self.buyer_reput_trans\n                mp_details['buyer_reput_reliability']=self.buyer_reput_reliability\n                mp_details['step']=self.step\n        return mp_details\n\n    def get_mp_info_archive(self,step):\n        mp_details=None\n        if step==self.step:\n            mp_details = {\"timestamp_nig\": self.timestamp_step4, \"readonly_flag\":False}\n        return mp_details\n\n    def step1(self,mp_request_name,buyer_public_key_hash,buyer_public_key_hex,requested_amount,smart_contract_ref,new_user_flag,buyer_reput_trans,buyer_reput_reliability):\n        if buyer_public_key_hash is not None and 'None' not in buyer_public_key_hash:\n            if self.step==0:\n                self.mp_request_name=mp_request_name\n                self.buyer_public_key_hash=buyer_public_key_hash\n                self.buyer_public_key_hex=buyer_public_key_hex\n                self.requested_amount=requested_amount\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)\n                self.step=1\n                self.smart_contract_ref=smart_contract_ref\n                self.timestamp_step1=datetime.timestamp(datetime.utcnow())\n                if new_user_flag==\"true\" or new_user_flag==\"True\":new_user_flag=True\n                if new_user_flag==\"false\" or new_user_flag==\"False\":\n                    new_user_flag=False\n                    self.requested_deposit=CONVERT_2_NIG(requested_amount,self.timestamp_nig,self.requested_currency)*GET_BUYER_SAFETY_COEF()\n                self.new_user_flag=new_user_flag\n                self.buyer_reput_trans=buyer_reput_trans\n                self.buyer_reput_reliability=buyer_reput_reliability\n            else:raise ValueError('request cannot be confirmed in step 1')\n        else:raise ValueError('Please select a buyer')\n\n    def step2(self,seller_public_key_hash,seller_public_key_hex,encrypted_account,mp_request_signature):\n        if seller_public_key_hash is not None and 'None' not in seller_public_key_hash:\n            if self.step==1:\n                self.seller_public_key_hash=seller_public_key_hash\n                self.seller_public_key_hex=seller_public_key_hex\n                self.timestamp_nig=datetime.timestamp(datetime.utcnow())\n                self.requested_nig_step2=copy.deepcopy(self.requested_nig)\n                self.requested_nig_step2_flag=True\n                self.requested_nig=CONVERT_2_NIG(self.requested_amount,self.timestamp_nig,self.requested_currency)\n                self.encrypted_account=encrypted_account\n                self.mp_request_signature=mp_request_signature\n                self.step=2\n                self.timestamp_step2=datetime.timestamp(datetime.utcnow())\n            else:raise ValueError('request cannot be confirmed in step 2')\n        else:raise ValueError('Please select a seller')\n            \n\n    def step3(self,mp_request_signature):\n        if self.step==2:\n            self.mp_request_signature=mp_request_signature\n            self.step=3\n            self.timestamp_step3=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in step 3')\n\n    def step4(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=4\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 4')\n\n    def step45(self,mp_request_signature):\n        if self.step==3:\n            self.mp_request_signature=mp_request_signature\n            self.step=45\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n            self.reputation_buyer=-1\n            self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in step 45')\n\n    def check_cancellation(self,mp_request_signature):\n        if self.step<3:\n          self.mp_request_signature=mp_request_signature\n          self.step=99\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:raise ValueError('request cannot be confirmed in cancellation')\n\n    def check_payment_default(self,mp_request_signature):\n        if self.step==3:\n          self.mp_request_signature=mp_request_signature\n          self.step=66\n          self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n          self.reputation_buyer=-1\n          self.reputation_seller=1\n        else:raise ValueError('request cannot be confirmed in payment default')\n\n    def validate_step(self):\n        signature_decoded = binascii.unhexlify(self.mp_request_signature.encode(\"utf-8\"))\n        if self.step==2 or self.step==4 or self.step==45 or self.step==66:\n            public_key_bytes = self.seller_public_key_hex.encode(\"utf-8\")\n        elif self.step==3 or self.step==99:\n            public_key_bytes = self.buyer_public_key_hex.encode(\"utf-8\")\n        else:\n            raise ValueError(f'request not in predefined step:{self.step}')\n      \n        public_key_object = RSA.import_key(binascii.unhexlify(public_key_bytes))\n        transaction_bytes = json.dumps(self.get_mp_details(self.step), indent=2).encode('utf-8')\n        transaction_hash = SHA256.new(transaction_bytes)\n        pkcs1_15.new(public_key_object).verify(transaction_hash, signature_decoded)\n\n    def check_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,False)\n\n    def validate_expiration(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        return self.check_expiration_raw(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,True)\n\n    def check_expiration_raw(self,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION,error_flag):\n        expiration_flag=False\n        check_now=datetime.timestamp(datetime.utcnow())\n        if self.step==1 and check_now-self.timestamp_step1>MARKETPLACE_STEP1_EXPIRATION:expiration_flag=True\n        if self.step==2 and check_now-self.timestamp_step2>MARKETPLACE_STEP2_EXPIRATION:\n            self.reputation_buyer=-1\n            expiration_flag=True\n        if self.step==3 and check_now-self.timestamp_step3>MARKETPLACE_STEP3_EXPIRATION:\n            self.reputation_seller=-1\n            expiration_flag=True\n        if expiration_flag is True:\n            self.step=98\n            self.timestamp_step4=datetime.timestamp(datetime.utcnow())\n        else:\n            if error_flag is True:ValueError('smart_contract is not expired')\n        return expiration_flag\n\t\t\n    def get_mp_info_and_expiration(self,step,user_public_key_hash,MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION):\n        mp_info=self.get_mp_info(step,user_public_key_hash)\n        expiration=self.check_expiration(MARKETPLACE_STEP1_EXPIRATION,MARKETPLACE_STEP2_EXPIRATION,MARKETPLACE_STEP3_EXPIRATION)\n        return mp_info,expiration,self.requested_amount,self.step\n\n    def cancel(self,user_public_key_hash,mp_request_signature):\n        if self.step<3 and self.buyer_public_key_hash==user_public_key_hash:\n            CANCEL_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'Cancellation not possible in step:{self.step} for user:{user_public_key_hash}')\n\n    def payment_default(self,user_public_key_hash,mp_request_signature):\n        if self.step==3 and self.seller_public_key_hash==user_public_key_hash:\n            PAYMENT_DEFAULT_SC(self.smart_contract_ref,self.step,mp_request_signature)\n        else:\n            raise ValueError(f'payment default not possible in step:{self.step} for user:{user_public_key_hash}')\n\n'''\nmarketplace_request_code=MarketplaceRequestCode()\nmemory_list.add([marketplace_request_code,'marketplace_request_code',['code']])\n123456\n", "smart_contract_result": 123456, "smart_contract_transaction_hash": "ba0a07ecb7d7150f798619f3c8c25495bdcb2ca16ab96afc53a494e83f46ecfe_0", "smart_contract_previous_transaction": null, "account_credit_list": ["abcd1234_0"], "inputs": [{"transaction_hash": "abcd1234", "output_index": 0, "unlocking_script": "040873960f23aeeeea51069ee02b8792f8a2b3b76467b34138109aa55b3e9bb0d5db97583637aa230b4630b4c0ee5afd071d7fad21e4d067d8e937f83eedb978383509b6d88d125aade061e42ff3a99f52ac01b8aa2e43dbb4534cf6d470bd0772f907b149d1686a0fa4be8422b11cf51b0f60a0ee25eb02de291e169900fe89bcb0bebf4cb78f97d724f76a5d624e34fb00e68a08a29909cf3db0adede69c863cd35d0e58478cb55ef3817afb3f8d417cc1324ae2d9a56270aadb454877231b8abe8090f7da428d78b845c69dc25538697a234d60992cc2dc350831e0d2b3a4bc3b61312ba4e07fc2cb4db2385b38bd37bc2f848ee03d58358b4567a31b29c2 30820122300d06092a864886f70d01010105000382010f003082010a0282010100e3d338c7a46785514c37293971ed3a5757fc5e9e3042bc9cba75504bde5eee57c9cc788506042425662a45d320ca23e5aaeb989e1719f064e6fe228d9f0a316a06acd708a5536bb5cc1e0b8307ee9848e00729d5a171f00e2a435e719be1da99d7039d8c331bf869270a537b104b228a91061ada0be7918e8d88c8adadb0be2823026b751db63d0b101d7146f5b50a463161877aa3130e69be35d5f4eb71073a40bd1766c4440709eae3c9f0bfbeed6fa28358334721d497b9f3d6c31b9a258fe1d89fe3ebf5bffafc36e9fc8cbd82a57b9bec0e4cea390df37a87d60d585e808559abd83d81a2f2737e235ce2fc0cdee68770d917bf093d0ad5645610b4f4230203010001", "unlocking_public_key_hash": "abcd1234_0", "network": "nig"}]}}, "debit": {}}}